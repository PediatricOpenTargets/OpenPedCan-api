# The working directory is the directory that contains this test R file, if this
# file is executed by test_dir
#
# testthat package is loaded, if this file is executed by test_dir
context("tests/r_test_scripts/test_endpoint_http.R")

# Function definitions ---------------------------------------------------------

# Send HTTP GET request and get response
#
# Args:
# - url: a single character value of url.
# - expected_response_code: a single integer value of expected HTTP response
#   code.
#
# Returns a list with time and content entries.
http_get <- function(url, expected_response_code) {
  stopifnot(is.character(url))
  stopifnot(identical(length(url), 1L))
  stopifnot(all(!is.na(url)))

  res <- httr::GET(url)

  testthat::expect_identical(
    res$status_code, expected_response_code,
    label = paste0("GET ", url, " response code"))

  res_list <- list(
    res_code = res$status_code,
    res_time = res$times,
    content = httr::content(res, "raw")
  )

  return(res_list)
}



# Test API endpoint through HTTP
#
# Args:
# - endpoint_spec: endpoint specification, with is a list with path and params
#   entries.
#
# Returns a list of endpoint response times.
test_endpoint <- function(endpoint_spec) {
  stopifnot(is.character(endpoint_spec$path))
  stopifnot(identical(length(endpoint_spec$path), 1L))
  stopifnot(all(!is.na(endpoint_spec$path)))
  stopifnot(all(nchar(endpoint_spec$path) > 0))

  stopifnot(is.character(endpoint_spec$params))
  stopifnot(all(!is.na(endpoint_spec$params)))
  stopifnot(all(nchar(endpoint_spec$params) > 0))

  param_val_comb_tbl <- purrr::cross_df(param_val_list[endpoint_spec$params])
  stopifnot(identical(sum(is.na(param_val_comb_tbl)), 0L))

  res_type_match_mat = stringr::str_match(endpoint_spec$path, "/([^/]+)$")
  stopifnot(identical(nrow(res_type_match_mat), 1L))
  stopifnot(identical(ncol(res_type_match_mat), 2L))
  stopifnot(identical(sum(is.na(res_type_match_mat)), 0L))

  res_type <- res_type_match_mat[1, 2]
  stopifnot(is.character(res_type))

  endpoint_output_id = stringr::str_replace_all(
    stringr::str_remove(endpoint_spec$path, "^/"), "/", "-")
  stopifnot(is.character(endpoint_output_id))
  stopifnot(identical(length(endpoint_output_id), 1L))

  test_url_glue_template <- paste0(
    base_url, endpoint_spec$path, "?",
    paste0(
      endpoint_spec$params, "={", endpoint_spec$params, "}", collapse = "&"))

  output_path_glue_template_list <- purrr::map(
    output_spec_list,
    function(output_spec) {
      output_path_glue_template <- file.path(
        output_spec$output_dir,
        paste0(
          "test-", endpoint_output_id, "-",
          paste0("{", endpoint_spec$params, "}", collapse = "-"),
          output_spec$output_sfx))
      return(output_path_glue_template)
    }
  )

  endpoint_test_tbl <- dplyr::mutate(
    param_val_comb_tbl, test_url = glue::glue(test_url_glue_template))

  # Helper function to get expected response code of HTTP request
  #
  # - hc_grp_tbl: group tibble, which does not have any group column, by the
  #   design of dplyr::group_modify.
  # - grp_key_tbl: group key tibble, a one row tibble of group columns.
  #
  # Returns a tibble with additional column expected_res_code.
  #
  # Note: whether certain efoId has primary or relapse samples passing minimum
  # number of sample filter is manually set using
  # db/build_outputs/tpm_data_lists.rds generated by db building process.
  get_expected_response_code <- function(grp_tbl, grp_key_tbl) {
    stopifnot(tibble::is_tibble(grp_tbl))
    stopifnot(tibble::is_tibble(grp_key_tbl))

    stopifnot(identical(nrow(grp_key_tbl), 1L))
    stopifnot(all(colnames(grp_key_tbl) %in% c("efoId", "includeTumorDesc")))

    res_code <- 200L  # nolint: object_usage_linter

    if ("efoId" %in% colnames(grp_key_tbl)) {
      if (grp_key_tbl$efoId == "Orphanet_178") {
        if (grp_key_tbl$includeTumorDesc %in%
              c("relapseOnly", "primaryAndRelapseInDifferentBoxes")) {
          res_code <- 500L
        }
      } else if (grp_key_tbl$efoId == "MONDO_0016718") {
        if (grp_key_tbl$includeTumorDesc %in%
              c("relapseOnly", "primaryAndRelapseInDifferentBoxes",
                "primaryAndRelapseInSameBox")) {
          res_code <- 500L
        }
      }
    }

    res_tbl <- dplyr::mutate(
      grp_tbl, expected_res_code = .env$res_code)  # nolint: object_usage_linter
    return(res_tbl)
  }

  if ("includeTumorDesc" %in% colnames(endpoint_test_tbl)) {
    if ("efoId" %in% colnames(endpoint_test_tbl)) {
      endpoint_test_tbl <- dplyr::ungroup(
        dplyr::group_modify(
          dplyr::group_by(endpoint_test_tbl, efoId, includeTumorDesc),
          get_expected_response_code)
      )
    } else {
      endpoint_test_tbl <- dplyr::ungroup(
        dplyr::group_modify(
          dplyr::group_by(endpoint_test_tbl, includeTumorDesc),
          get_expected_response_code)
      )
    }
  } else {
    # Differential expression database currently do not have these EFO IDs.
    #
    # TODO: change after loading new DESeq data.
    if ("efoId" %in% colnames(endpoint_test_tbl)) {
      endpoint_test_tbl <- dplyr::mutate(
        endpoint_test_tbl,
        expected_res_code = dplyr::if_else(
          condition = .data$efoId %in% c("Orphanet_178", "MONDO_0016718",
                                        "MONDO_0016680", "MONDO_0016685"),
          true = 500L, false = 200L))
    } else {
      endpoint_test_tbl <- dplyr::mutate(
        endpoint_test_tbl,
        expected_res_code = 200L)
    }
  }

  if (res_type == "json") {
    endpoint_test_tbl <- dplyr::mutate(
      endpoint_test_tbl,
      output_json_path = glue::glue(output_path_glue_template_list$json),
      output_tsv_path = glue::glue(output_path_glue_template_list$tsv))

    res_time_list <- purrr::pmap(
      endpoint_test_tbl[, c("test_url", "output_json_path", "output_tsv_path",
                            "expected_res_code")],
      function(test_url, output_json_path, output_tsv_path, expected_res_code) {
        res_list <- http_get(test_url, expected_res_code)

        if (expected_res_code == 200L) {
          writeBin(res_list$content, output_json_path)
          readr::write_tsv(
            jsonlite::fromJSON(output_json_path), output_tsv_path)
        }

        return(res_list)
      }
    )

  } else if (res_type == "plot") {
    endpoint_test_tbl <- dplyr::mutate(
      endpoint_test_tbl,
      output_png_path = glue::glue(output_path_glue_template_list$png))

    res_time_list <- purrr::pmap(
      endpoint_test_tbl[, c("test_url", "output_png_path",
                            "expected_res_code")],
      function(test_url, output_png_path, expected_res_code) {
        res_list <- http_get(test_url, expected_res_code)

        if (expected_res_code == 200L) {
          writeBin(res_list$content, output_png_path)
        }

        return(res_list)
      }
    )

  } else {
    stop(paste0("Unknown response type ", res_type))
  }

  res_time_df <- purrr::map_dfr(res_time_list, function(xl) {
    rt_dfr <- tibble::tibble(
      endpoint = endpoint_spec$path,
      response_code = as.character(xl$res_code),
      response_time_in_seconds = xl$res_time["total"])
  })

  return(res_time_df)
}


# Data variable definitaions ---------------------------------------------------

base_url <- Sys.getenv("BASE_URL", unset = NA_character_)
stopifnot(!is.na(base_url))
stopifnot(is.character(base_url))
stopifnot(identical(length(base_url), 1L))

param_val_list <- list(
  ensemblId = c("ENSG00000213420", "ENSG00000157764", "ENSG00000273032"),

  efoId = c("EFO_0000621", "Orphanet_178", "MONDO_0016718",
            "MONDO_0016680", "MONDO_0016685"),

  yAxisScale = c("linear", "log10"),

  includeTumorDesc = c("primaryOnly", "relapseOnly",
                       "primaryAndRelapseInSameBox",
                       "primaryAndRelapseInDifferentBoxes"),

  rankGenesBy = c("cgc_all_gene_up_reg_rank",
                  "cgc_all_gene_down_reg_rank",
                  "cgc_all_gene_up_and_down_reg_rank",
                  "cgc_pmtl_gene_up_reg_rank",
                  "cgc_pmtl_gene_down_reg_rank",
                  "cgc_pmtl_gene_up_and_down_reg_rank")
)

endpoint_spec_list <- list(
  list(
    path = "/tpm/gene-disease-gtex/json",
    params = c("ensemblId", "efoId", "includeTumorDesc")),
  list(
    path = "/tpm/gene-disease-gtex/plot",
    params = c("ensemblId", "efoId", "yAxisScale", "includeTumorDesc")),

  list(
    path = "/tpm/gene-all-cancer/json",
    params = c("ensemblId", "includeTumorDesc")),
  list(
    path = "/tpm/gene-all-cancer/plot",
    params = c("ensemblId", "yAxisScale", "includeTumorDesc")),

  list(
    path = "/tpm/gene-all-cancer-collapsed-gtex/json",
    params = c("ensemblId", "includeTumorDesc")),
  list(
    path = "/tpm/gene-all-cancer-collapsed-gtex/plot",
    params = c("ensemblId", "yAxisScale", "includeTumorDesc")),

  list(
    path = "/tpm/gene-all-cancer-gtex/json",
    params = c("ensemblId", "includeTumorDesc")),
  list(
    path = "/tpm/gene-all-cancer-gtex/plot",
    params = c("ensemblId", "yAxisScale", "includeTumorDesc")),

  list(
    path = "/dge/top-gene-disease-gtex-diff-exp/json",
    params = c("efoId", "rankGenesBy")),
  list(
    path = "/dge/top-gene-disease-gtex-diff-exp/plot",
    params = c("efoId", "rankGenesBy")),

  list(
    path = "/dge/gene-all-cancer-gtex-diff-exp/json",
    params = c("ensemblId")),
  list(
    path = "/dge/gene-all-cancer-gtex-diff-exp/plot",
    params = c("ensemblId"))
)

output_spec_list <- list(
  tsv = list(
    output_dir = file.path("..", "results", "tsv"),
    output_sfx = ".tsv"),
  json = list(
    output_dir = file.path("..", "http_response_output_files", "json"),
    output_sfx = ".json"),
  png = list(
    output_dir = file.path("..", "http_response_output_files", "png"),
    output_sfx = ".png")
)



# Run tests and summarise results ----------------------------------------------
endpoint_res_time_df <- purrr::map_dfr(endpoint_spec_list, test_endpoint)

readr::write_tsv(
  endpoint_res_time_df,
  file.path("..", "results", "endpoint_response_times.tsv"))

endpoint_res_time_df <- dplyr::add_count(
  endpoint_res_time_df, endpoint, name = "n_requests")

endpoint_res_time_df <- dplyr::mutate(
  endpoint_res_time_df,
  x_label = paste0(
    .data$endpoint, "\n     (Number of requests = ",
    .data$n_requests, ")"),
  res_desc = dplyr::case_when(
    .data$response_code == "200" ~ "PNG plot or JSON table",
    .data$response_code == "500" ~ "Requested data are not available",
    TRUE ~ NA_character_
  )
)

endpoint_res_time_boxplot <- ggplot2::ggplot(endpoint_res_time_df,
                                             ggplot2::aes(
                                               x = x_label,
                                               y = response_time_in_seconds,
                                               color = res_desc)) +
  ggplot2::stat_boxplot(
    geom = "errorbar", width = 0.25,
    position = ggplot2::position_dodge(0.5)) +
  ggplot2::geom_boxplot(
    lwd = 0.5, fatten = 0.7, outlier.shape = 1,
    width = 0.5, outlier.size = 1,
    position = ggplot2::position_dodge(0.5)) +
  ggplot2::ylim(0, NA) +
  ggplot2::ylab(paste0(
    "Response time in seconds\n",
    "to each serial HTTP request")) +
  ggplot2::xlab("Endpoint path") +
  ggplot2::ggtitle(paste("API HTTP server base URL:\n", base_url)) +
  ggplot2::guides(
    color = ggplot2::guide_legend(
      title = "Expected HTTP response")) +
  ggplot2::scale_color_manual(
    values = c(
      "PNG plot or JSON table" = "#56B4E9",
      "Requested data are not available" = "#E69F00")) +
  ggplot2::theme_light(base_size = 20, base_family = "Helvetica") +
  ggplot2::theme(
    axis.title.y = ggplot2::element_text(size = 20, color = "#000000"),
    axis.text.x = ggplot2::element_text(
      size = 20, color = "#000000", angle = -45, vjust = 1, hjust = 0),
    legend.text = ggplot2::element_text(size = 18, color = "#000000"),
    legend.key.size = grid::unit(2, "line"))

ggplot2::ggsave(
  file.path("..", "plots", "endpoint_response_time_boxplot.png"),
  endpoint_res_time_boxplot,
  width = (2 * length(unique(endpoint_res_time_df$x_label))) + 6, height = 11)
